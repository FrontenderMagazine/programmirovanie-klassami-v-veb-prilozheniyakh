#Программирование классами в веб-приложениях

 Сегодня не часто можно встретить программиста-одиночку или приложение-однодневку. Для достижения наилучших результатов мы объединяемся в команды, развиваемся, внедряем новые технологии. Мы много работаем, пишем много кода, еще чуть-чуть и наше приложение станет практически совершенным, но вдруг мы понимаем, что больше не можем управлять им. Оно становится громоздким. Куски не структуированного кода накладываются друг на друга, образуя черную дыру, которая засасывает весь проект в пучину хаоса.

> Если ты смотришь на код в течении 5 минут и не можешь понять, что он делает, то это плохой код.
>
> -- <cite>Олег Лукавенко (один из моих работодателей)</cite>

В данной публикации речь пойдет о том, как писать красивый, понятный, высокоуровневый код веб-приложения, который легко читать и поддерживать. Мы рассмотрим, как расширить порог входа для новых программистов, как позволить им быстро разобраться в структуре данных и, конечно, как получать удовольствие от работы с кодом.

###Как корабль назовешь, так он и поплывет.

Разрабатывая клиентское веб-приложение необходимо заранее подумать о том, каким образом члены одной команды разработчиков будут взаимодействовать с проектом и, что более важно, необходимо заранее предвидеть, как будет выглядеть код приложения через несколько лет. Плохо, когда архитектура приложения хранится в голове одного человека. Люди не постоянны и порой даже не предсказуемы. Хорошо, когда архитектура приложения понятна с первого взгляда (и задокументирована). На сегодняшний день в вопросе архитектуры веб-приложений на клиенте хорошо зарекомендовал себя Backbone. Но я бы не стал утверждать, что Backbone - это новаторское решение. Как раз наоборот. Разработчики Backbone обратили внимание мирового сообщества на то, что всегда было в JavaScript, а именно на возможность **программирования классами**.

JavaScript устроен таким образом, что все в нем является объектами. Строки, массивы, числа - это объекты JavaScript. По этой причине понятие **классы в JavaScript** никогда не применялось или применялось разве что в разговорной речи. В JavaScript более распространено такое понятие, как **функции-конструкторы**, но для удобства я буду называть их классами.

Далее я постараюсь раскрыть тему статьи на примере 3-х вымышленных frontend разработчиков, которые выполняют одну и ту же задачу, а именно **вычислить discount для товара и вывести цену на HTML страницу**.

###Junior, Middle and Senior developers

Посмотрим что же напишет Junior developer:

```javascript
var discount = 0.10;
$('.products').each(function() {
    var price = $(this).find('.price').html();
    var discountedPrice = price - (price * discount);
    $(this).find('.price').html(discountedPrice);
});
```
С одной стороны задача выполнена, но тут мы имеем массу явных минусов, которые затянут проект в черную дыру:

 1. Данные берутся прямо из HTML страницы;
 2. Нет модели данных;
 3. Строковая математика;
 4. Код тяжелый для зрительного восприятия;
 4. Чтобы понять назначение отдельной части кода надо прочитать весь код целиком (затрата времени и умственных ресурсов);
 5. Код не расширяемый

Теперь усложним задачу джуниору. Допустим, нам понадобились разные дискаунты для конкретных типов товаров и мы просим его доработать функционал. Внезапно на лбу джуниора выступают капельки пота, по спине пробегают мурашки и он суетливо начинает искать выход из ситуации:

```javascript
var discountByTypes= {
    cheap: 0.20,
    expensive: 0.10
};
$('.products').each(function() {
    var price = $(this).find('.price').html();
    var type = $(this).data('type');

    if (type === 'cheap') {
		var discountedPrice = price - (price * discountByTypes.cheap);
	}

	if (type === 'expensive') {
		var discountedPrice = price - (price * discountByTypes.expensive);
	}

    $(this).find('.price').html(discountedPrice);
});
```

Код стал более запутанным и еще более сложным для восприятия. Уже на этом этапе можно сказать, что через 2 месяца активной жизни веб-приложения с кодом будет невозможно работать, а главное не приятно. Ведь работа должна доставлять удовольствие. Только представьте, если строк такого кода будет 10.000.

Теперь посмотрим, как справится с задачей middle developer.

```javascript
var productDiscount = {

	discountByTypes: {
	    cheap: 0.20,
	    expensive: 0.10
	},
	
	getDiscoutedPrice: function(price, discount) {
		return price - (price * discount);
	},

	getDiscountedByType: function(price, type) {
		return this.getDiscoutedPrice(price, this.discountByTypes[type]);
	},

	setPrice: function(elem, price, type) {
		var discountedPrice = this.getDiscountedByType(price, type);
		elem.html(discountedPrice);
	},

	init: function() {
		$('.products').each(function() {
			var price = $(this).find('.price').html(),
				type = $(this).data('type');

			productDiscount.setPrice($(this).find('.price'), price, type);
		});
	}
}

productDiscount.init();
```

Уже намного лучше. Middle developer создал объект productDiscount, каждый метод которого имеет свое уникальное имя. Также он сделал функцию-инициализатор класса init(). Что изменилось по сравнению с вариантом джуниора?

 2. Код стал проще для восприятия;
 3. Разделение кода на блоки;
 4. Наименование методов говорят сами за себя. Теперь не нужно читать весь код чтобы понять (изменить) отдельную его часть.
 5. Код можно расширять новыми методами и свойствами.

Данный вариант значительно лучше. Хороший код всегда читается, как открытая книга. Чем больше код похож на человеческую речь, тем лучше. Это и отличает языки высокого уровня от низкоуровневых языков. Но у нас по прежнему нет модели данных! Мы оперируем данными с веб страницы и используем строковую математику. Что нам ответит на это Senior developer? Он будет программировать классами. Все вы знаете о таких конструкциях в JavaScript, как new Object(), new String(). Но, к великому сожалению, не все знают, что могут создавать самостоятельно подобные функции-конструкторы и работать с их экземплярами.

Когда мы создаем, например, new Object(), то получаем на вооружение не только сам объект, но и все его свойства и методы. Мы можем создать десятки тысяч экземпляров объекта, а методы и свойства у него всегда будут одинаковые. Если добавить новый метод в модель, у всех 10.000 экземпляров он появится тоже. Если нам потребуется добавить новое свойство, то мы опять же добавим его в модель. Данный подход раскрывает перед нами поистине безграничные возможности. Модель - это сердце веб-приложения.  Теперь давайте посмотрим, как Senior developer решит поставленную задачу.

```javascript
function Product(config) {
    var config = config;

	this.getDiscountedPrice = function() {
		return config.price - (config.price * config.discount);
	}

    this.writeDiscountedPriceTo = function(elem) {
		elem.html(this.getDiscountedPrice());
    }

	return this;
}

```

Вот собственно и все. Такой небольшой, понятный и лаконичный фрагмент кода открывает перед нами большие горизонты. Теперь мы можем создавать экземпляры продукта до тех пор, пока не закончится оперативная память. И все они будут содержать методы getDiscountedPrice и writeDiscountedPriceTo.

Тут же хочется рассказать об общепринятых в мировом сообществе правилах:

 1. Наименование функции-конструктора (класса) всегда начинаются с заглавной буквы;
 2. Экземпляры класса начинаются строчной буквой;
 3. Постарайтесь во всех классах использовать переменную config для конфигурирования класса

```javascript
// Создаем экземпляр класса и передаем ему конфиг
var product_1 = new Product({
	price: 199,
	discount: 0.20,
	type: 'cheap'
});

// Пример использования метода класса
product_1.writeDiscountedPriceTo( $('#product_1') );

var product_2 = new Product({
	price: 399,
	discount: 0.10,
	type: 'expensive'
});

product_2.writeDiscountedPriceTo( $('#product_2') );
```

Как видно из примера, Senior создал 2 продукта и, используя метод writeDiscountedPriceTo(), вывел стоимость на HTML страницу. Обратите внимание, что Senior написал методы класса только 1 раз и далее создавал только экземпляры этого класса при помощи конструкции new Product(), каждый из из которых уже содержал все методы и свойства класса Product.

Теперь немного расширим нашу модель.

```javascript
function Product(config) {
    var config = config;

	this.getDiscountedPrice = function() {
		return config.price - (config.price * config.discount);
	}

    this.writeDiscountedPriceTo = function(elem) {
		elem.html(this.getDiscountedPrice());
    }

	this.getType = function() { // NEW
		return config.type;
	}

    this.getPrice = function() { // NEW
		return config.price;
	}

	return this;
}

```

Отлично. Мы только что добавили новый метод getPrice в нашу модель, который будет возвращать прайс без учета скидки. Также мы добавили метод getType, который возвращает тип товара. Обратите внимание на то, что мы добавили эти методы в одном месте, но не смотря на это у всех экземпляров класса эти методы тоже появятся.

Этот процесс бесконечный. Мы можем расширять класс Product сколько угодно. Также мы можем, например, создать новый класс ProductCollection, который будем наполнять экземплярами Product через метод add.

```javascript
function ProductCollection(config) {
    var config = config,
	    storage = [];

	this.add = function(product) {
		storage.push(product);
	}

	this.getProductsByType = function(type) {
		// Напишите метод самостоятельно. Должен возвращать массив товаров с типом type
	}

	return this;
}

var collection = new ProductCollection();
collection.add(product_1);
collection.add(product_2);
```

Теперь в нашей коллекции содержится 2 товара. Мы можем написать методы для работы с целыми коллекциями данных. Попробуйте самостоятельно доавить в ProductCollection новый метод getProductsByType.

###Способы хранения классов

Каждый класс обычно помещается в файл с наименованием класса. Например product.class.js или productCollection.class.js. Для удобства файлы размещаются в папочку с model или core. Это позволяет использовать системный подход и не запутаться, когда количество классов достигает десятков или сотен. 

Для программирования классами удобно использовать сборщик проектов на Node.js. Из наиболее известных можно выделить Gulp и Grunt. Данные инструменты позволят вам собирать и классы в один файл для дальнейшего использования в проекте.

Также хотелось бы отметить высокую мобильность такого подхода. Достаточно один раз написать класс чтобы потом использовать его в большом количестве проектов. В идеале каждый класс должен быть независимым и иметь возможность безболезненного импорта в другие проекты. Исключением могут быть, разве что, коллекции.

###Подведем итоги

 2. Это нативный JavaScript и его фундаментальные принципы;
 3. Мы получаем модель данных и возможность управлять ей;
 3. Данные не зависят от шаблона;
 4. Мы можем изменять шаблон (HTML) и не бояться потерять данные;
 3. Нам больше не требуется строковая математика;
 4. Классы можно импортировать в другие проекты;
 5. Код легкий для восприятия;
 6. Код легко читается благодаря синтаксису, приближенному к человеческой речи;
 7. Код расширяется до бесконечности без риска попасть в черную дыру;
 8. Код легко документируется. Достаточно лишь описать класс и его методы
 9. Высокий порог входа в проект других разработчиков
